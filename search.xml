<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法题(一)</title>
      <link href="2021/03/31/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>2021/03/31/%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=430 height=86 src="//music.163.com/outchain/player?type=2&id=114389&auto=0&height=66"></iframe><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个字符串s，找到s中最长的回文子串。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>输入:s=”babad”<br>输出:”baa”<br>解释:”aba”同样符合题意</p><h2 id="方法一：暴力求解"><a href="#方法一：暴力求解" class="headerlink" title="方法一：暴力求解"></a>方法一：暴力求解</h2><p>暴力求解是最容易想到的，要截取字符串的所有子串，然后再判断这些子串中哪些是回文<br>的，最后返回回文子串中最长的即可。</p><p>这里我们可以使用两个变量，一个记录最长回文子串开始的位置，一个记录最长回文子串<br>的长度，最后再截取。代码如下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public String longestPalindrome(String s)&#123;if(s.length()&lt;2)&#123; return s&#125;;int start&#x3D;0,MaxLen&#x3D;0;for(int i&#x3D;0;i&lt;s.length()-1;i++)&#123;for(int j&#x3D;0;j&lt;s.length();j++)&#123;if(j-i&lt;MaxLen)&#123;continue;&#125;if(isPalindrome(s,i,j))&#123;if(MaxLen&lt;j-i+1)&#123;start&#x3D;i;MaxLen&#x3D;j-i+1;&#125;&#125;&#125;&#125;return s.substring(start,start+MaxLen);&#125; private boolean isPalindrome(String s,int i,int j)&#123;while(i&lt;j)&#123;if(s.charAt(i++) !&#x3D; s.charAt(j--)&#123;return false;&#125;&#125;return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法二：-动态规划"><a href="#方法二：-动态规划" class="headerlink" title="方法二： 动态规划"></a>方法二： 动态规划</h2><p>定义二维数组dp[length][length]，如果dp[left][right]为true，则表示字符串从left到right<br>是回文子串，如果dp[left][right]为false，则表示字符串从left到right不是回文子串。</p><p>如果dp[left+1][right -1]为true，我们判断s.charAt(left)和s.charAt(right)是否相等，如果<br>相等，那么dp[left][right]肯定也是回文子串，否则dp[left][right]一定不是回文子串。</p><p>所以我们可以找出递推公式</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dp[left][right]&#x3D;s.charAt(left)&#x3D;&#x3D;s.charAt(right)&amp;&amp;dp[left+1][right-1]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有了递推公式，还要确定边界条件：<br>如果s.charAt(left)！=s.charAt(right)，那么字符串从left到right是不可能构成子串<br>的，直接跳过即可。</p><p>如果s.charAt(left)==s.charAt(right)，字符串从left到right能不能构成回文子串还<br>需要进一步判断<br>    如果left==right，也就是说只有一个字符，我们认为他是回文子串。即dp[left][right]=true（left==right）<br>    如果right-left&lt;=2，类似于”aa”，或者”aba” ，我们认为他是回文子串 。 即dp[left][right]=true（right-left&lt;=2）<br>    如果right-left&gt;2，我们只需要判断dp[left+1][right-1]是否是回文子串，才能确定dp[left][right]是否为true还是false。<br>即dp[left][right]=dp[left+1][right -1]。</p><p>代码如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> 1public static String longestPalindrome(String s) &#123; 2     &#x2F;&#x2F;边界条件判断 3     if (s.length() &lt; 2) 4        return s; 5     &#x2F;&#x2F;start表示最长回文串开始的位置， 6     &#x2F;&#x2F;maxLen表示最长回文串的长度 7     int start &#x3D; 0, maxLen &#x3D; 1; 8     int length &#x3D; s.length(); 9     boolean[][] dp &#x3D; new boolean[length][length];10     for (int right &#x3D; 1; right &lt; length; right++) &#123;11           for (int left &#x3D; 0; left &lt; right; left++) &#123;12               &#x2F;&#x2F;如果两种字符不相同，肯定不能构成回文子串13               if (s.charAt(left) !&#x3D; s.charAt(right))14                   continue;1516               &#x2F;&#x2F;下面是s.charAt(left)和s.charAt(right)两个17               &#x2F;&#x2F;字符相同情况下的判断18               &#x2F;&#x2F;如果只有一个字符，肯定是回文子串19               if (right &#x3D;&#x3D; left) &#123;20               dp[left][right] &#x3D; true;21               &#125; else if (right - left &lt;&#x3D; 2) &#123;22               &#x2F;&#x2F;类似于&quot;aa&quot;和&quot;aba&quot;，也是回文子串23               dp[left][right] &#x3D; true;24               &#125; else &#123;25               &#x2F;&#x2F;类似于&quot;a******a&quot;，要判断他是否是回文子串，只需要26               &#x2F;&#x2F;判断&quot;******&quot;是否是回文子串即可27               dp[left][right] &#x3D; dp[left + 1][right - 1];28               &#125;29               &#x2F;&#x2F;如果字符串从left到right是回文子串，只需要保存最长的即可30               if (dp[left][right] &amp;&amp; right - left + 1 &gt; maxLen) &#123;31               maxLen &#x3D; right - left + 1;32               start &#x3D; left;33            &#125;34    &#125;35    &#x2F;&#x2F;截取最长的回文子串36    return s.substring(start, start + maxLen);37 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
